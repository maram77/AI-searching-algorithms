# -*- coding: utf-8 -*-
"""taquin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IGhkv-h6zQL_9Y7Fnx-83WSlHDGQNCNs

Les fonctions basiques :
"""

from copy import deepcopy
import time

t = [[1,2,3],[8,6,0],[7,5,4]]  #etat initiale
tf =[[1,2,3],[8,0,4],[7,6,5]]  #etat finale

def estEtatFinal (t,tf):
  return t==tf

def position_case_vide(t):
    for row in range(len(t)):
        for col in range(len(t[row])):
            if t[row][col] == 0 : 
                return (row,col)

def numero(t,x,y):
  return t[x][y]

def permuter(t, pos, move):
    temp = deepcopy(t)
    i, j = pos  # ancienne position de vide
    x, y = move  # nouvelle position de vide
    temp[i][j], temp[x][y] = temp[x][y], temp[i][j]  # permutation, the python way
    return temp

def afficher(t):
  print()
  for i in range(len(t)):
    for j in range(len(t[i])):
      print('+-----',end='')
    print('+')
    for j in range(len(t[i])):
      if t[i][j] != 0:
        print('| ',t[i][j],' ',end='')
      else:
        print('|     ',end='')
    print('|')
  for j in range(len(t[i])):
    print('+-----',end='')
  print('+')

def valid(x,y):
    return x>-1 and x<3 and y>-1 and y<3
def transitions(t) :
  pos=position_case_vide(t)
  liste = []
  x = [1,0,-1,0]
  y = [0,1,0,-1]
  for i in range(4):
    if(valid(pos[0]+x[i],pos[1]+y[i])):
       liste.append([pos[0]+x[i],pos[1]+y[i]])
  derive=[]
  for i in liste :
    derive.append(permuter(t,pos,i))
  return derive

"""Recherche A Etoile :"""

def h(t,tf):
  nb=0
  for i in range(len(t)):
    for j in range(len(t[i])):
      if (t[i][j]!=tf[i][j])and (t[i][j]!=0):
        nb=nb+1
  return nb

def aetoile(t,tf):
  success=False
  start = time.time()
  niveaux = 0
  free_nodes = []
  free_nodes.append(t)
  closed_nodes = []
  while (free_nodes!=[]) and (not success) and (niveaux < 100):
    first_node = free_nodes[0]
    print()
    print ('** pas', niveaux,': **')
    niveaux += 1
    afficher(first_node)
    free_nodes.remove(first_node)
    closed_nodes.append(first_node)
    generated_states = transitions(first_node)

    for s in generated_states:
      if s == tf:
        success = True
        print (' \n** pas', niveaux,': **')
        afficher(s)
        goal_node = s
    free_nodes = free_nodes + generated_states
    free_nodes.sort(key = lambda el:(niveaux+h(el,tf)))

  if niveaux == 100:
    print("Recherche non conclussive")
  else:
    print(" \n --> Goal trouvé aprés",niveaux," iterations .")
  print ('Time spent: %0.2fs' % (time.time()-start))

print (h(t,tf),"cases mal placées depuis l'etat initial")
aetoile(t,tf)

""" Recherche en profondeur d'abord : """

trace= []
visited= []
success= False
def dfs(t, tf):
  global start 
  start= time.time()
  global success
  if (success==False and t not in visited):
    trace.append(t)
    if estEtatFinal(t,tf):
      success=True
    visited.append(t)
    tab=transitions(t)
    for i in tab:
      if i not in visited and success==False:
         dfs(i,tf)
dfs(t,tf)
niveaux=0
for i in trace :
  print()
  print ('** pas', niveaux,' : **')
  afficher(i)
  niveaux+=1
print("\n --> Goal trouvé aprés",niveaux-1," iterations .")
print ('Time spent: %0.2fs' % (time.time()-start))

"""Recherche en largeur d'abord :"""

def bfs(t, tf):
  global start
  start=time.time()
  visited=[]
  queue=[]
  queue.append(t)
  visited.append(t)
  trace=[]
  while queue:
    f=queue.pop(0)
       
    if estEtatFinal(f,tf):
      trace.append(f)
      success=True
      break
    trace.append(f)
    trs=transitions(f)
    for j in trs:
     if j not in visited:
      visited.append(j)
      queue.append(j)
  return trace


niveaux=0
trace=bfs(t, tf)
for i in trace : 
   print()
   print ('** pas', niveaux,': **')
   afficher(i)
   niveaux+=1
print("\n --> Goal trouvé aprés",niveaux-1," iterations . \n")
print ('Time spent: %0.2fs' % (time.time()-start))